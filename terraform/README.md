# Terraform

This directory holds the terraform module for maintaining the system infrastructure and deploying the application.

## Terraform State Credentials

The `bootstrap` module is used to create an s3 bucket for later terraform runs to store their state in as well as
create credentials files so developers can use that s3 bucket to create their own sandbox environments.

### Initial project setup

These steps only need to be run once per project.

1. `cd bootstrap`
1. Add any users who should have access to the terraform state bucket to `users.auto.tfvars`
1. Run `./apply.sh -var create_bot_secrets_file=true`
1. Add `imports.tf` to git and commit the changes
1. Setup your CI/CD Pipeline to run terraform and deploy your staging and production environments
    1. Copy backend credentials from `/terraform/.shadowenv.d/500_tf_backend_secrets.lisp` to your CI/CD secrets using the instructions in the base README
    1. Copy the `cf_user` and `cf_password` credentials from `/terraform/secrets.cicd.tfvars` to your CI/CD secrets using the instructions in the base README
1. Delete `/terraform/secrets.cicd.tfvars`
1. Delete `/terraform/.shadowenv.d/500_tf_backend_secrets.lisp` if you won't be running terraform locally

### To make changes to the bootstrap module

*This should not be necessary in most cases, other than adding or removing users who should have access to the state bucket in `bootstrap/users.auto.tfvars`*

1. Make your changes
1. Run `./apply.sh` and verify the plan before entering `yes`
1. Commit any changes to `imports.tf`

## Set up a sandbox environment or review app

### Pre-requisites:

1. Someone on the team has run the [Initial project setup](#initial-project-setup) steps and `imports.tf` is up-to-date on your branch.
1. You are included in the list of users in `bootstrap/users.auto.tfvars` and `bootstrap/imports.tf`

### Steps:

1. Create a new `sandbox-<NAME>.tfvars` file to hold variable values for your environment. A good starting point is copying `staging.tfvars` and editing it with your values
1. Add a `cf_user = "your.email@agency.gov"` line to the `sandbox-<NAME>.tfvars` file

1. Run terraform plan with:
    ```bash
    ./terraform.sh -e sandbox-<NAME>
    ```

1. Apply changes with:
    ```bash
    ./terraform.sh -e sandbox-<NAME> -c apply
    ```

1. Optional: tear down the sandbox if it does not need to be used anymore
    ```bash
    ./terraform.sh -e sandbox-<NAME> -c destroy
    ```

## Structure

```
|- bootstrap/
|  |- main.tf
|  |- apply.sh
|  |- imports.tf (automatically generated)
|  |- users.auto.tfvars
|  |- terraform.tfstate(.backup) (automatically generated)
|  |- templates/
|     |- backend_config.tftpl
|     |- bot_secrets.tftpl
|     |- imports.tf.tftpl
|- dist/
|  |- src.zip (automatically generated)
|- README.md
|- app.tf
|- main.tf
|- providers.tf
|- terraform.sh
|- variables.tf
|- <env>.tfvars
```

In the root module:
- `<env>.tfvars` is where to set variable values for the given environment name
- `terraform.sh` Helper script to setup terraform to point to the correct state file, create a service account to run the root module, and apply the root module.
- `app.tf` defines the application resource and configuration
- `main.tf` defines the persistent infrastructure
- `providers.tf` lists the required providers and shell backend config
- `variables.tf` lists the variables that will be needed

In the bootstrap module:
- `main.tf` sets up a management space, an s3 bucket to store terraform state files, and an initial SpaceDeployer for the system
- `apply.sh` Helper script to either recreate the state locally or call `terraform apply` Any arguments are passed through to the `apply` call
- `imports.tf` import blocks to create a new local state file when new developers need to access the state file. This file is automatically generated by calling `./apply.sh` and should be checked into git on any changes
- `users.auto.tfvars` this file defines the list of cloud.gov accounts that should have access to the terraform state bucket
